// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title BabyBNB Token - Final Optimized Version
 * @dev Deflationary token with reflection mechanism and enhanced security
 * 
 * Features:
 * - 7% burn fee (reduces total supply)
 * - 2% reflection fee (automatic redistribution to holders)
 * - 1% creator fee (to project wallet)
 * - Minimum supply protection (210M tokens)
 * - Emergency pause functionality
 * - Configurable exclusions
 * - Timelock for critical operations
 */
contract BabyBNB is ERC20, Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    /* ---------------------------------------------------------- *
     * CONSTANTS & CONFIGURATION                                   *
     * ---------------------------------------------------------- */
    uint8 public constant DECIMALS = 9;
    uint256 public constant INITIAL_SUPPLY = 420_000_000_000_000_000 * 10**DECIMALS; // 420 Quadrillion
    uint256 public constant MIN_SUPPLY = 210_000_000 * 10**DECIMALS; // 210 Million
    uint256 public constant MAX_FEE_BPS = 1_000; // 10% maximum total fees
    uint256 public constant TIMELOCK_DURATION = 1 hours;
    uint256 private constant MAX = type(uint256).max;

    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;

    /* ---------------------------------------------------------- *
     * STATE VARIABLES                                             *
     * ---------------------------------------------------------- */
    address public creatorWallet;
    
    // Fee structure (in basis points)
    uint256 public burnFeeBps = 700;       // 7%
    uint256 public reflectionFeeBps = 200; // 2%
    uint256 public creatorFeeBps = 100;    // 1%
    
    bool public feesActive = true;
    bool private _inSwap; // Prevent recursion
    
    // Timelock for critical operations
    uint256 public nextToggleFeesTime;
    bool public pendingToggleFeesState;

    // Simplified reflection system
    uint256 private _rTotal; // Total reflections
    uint256 private _tFeeTotal; // Total fees collected for reflections
    
    // Exclusion mappings
    mapping(address => bool) public isExcludedFromFees;
    mapping(address => bool) public isExcludedFromReflections;
    mapping(address => uint256) private _rOwned;
    mapping(address => uint256) private _tOwned;
    
    // Array of excluded addresses
    address[] private _excluded;
    uint256 public constant MAX_EXCLUDED_ACCOUNTS = 50;

    /* ---------------------------------------------------------- *
     * EVENTS                                                      *
     * ---------------------------------------------------------- */
    event FeesUpdated(uint256 burnFee, uint256 reflectionFee, uint256 creatorFee);
    event FeesToggled(bool active);
    event ExclusionUpdated(address indexed account, bool excludedFromFees, bool excludedFromReflections);
    event CreatorWalletUpdated(address indexed oldWallet, address indexed newWallet);
    event TokensBurned(address indexed from, uint256 amount);
    event ReflectionDistributed(uint256 amount);
    event MinimumSupplyReached();

    /* ---------------------------------------------------------- *
     * MODIFIERS                                                   *
     * ---------------------------------------------------------- */
    modifier validAddress(address addr) {
        require(addr != address(0), "Invalid address: zero address");
        _;
    }

    modifier notSystemAddress(address addr) {
        require(
            addr != address(this) && 
            addr != BURN_ADDRESS && 
            addr != creatorWallet,
            "Cannot modify system address"
        );
        _;
    }

    modifier lockTheSwap {
        _inSwap = true;
        _;
        _inSwap = false;
    }

    /* ---------------------------------------------------------- *
     * CONSTRUCTOR                                                 *
     * ---------------------------------------------------------- */
    constructor() 
        ERC20("Baby BNB", "BBNB") 
        Ownable(msg.sender)
    {
        creatorWallet = msg.sender;
        
        // Initialize reflection total
        _rTotal = MAX - (MAX % INITIAL_SUPPLY);
        
        // Setup exclusions BEFORE minting
        _setupInitialExclusions();
        
        // Mint initial supply
        _mint(msg.sender, INITIAL_SUPPLY);
        
        // Set initial balance for reflection system
        _tOwned[msg.sender] = INITIAL_SUPPLY;
    }

    /* ---------------------------------------------------------- *
     * REFLECTION SYSTEM                                           *
     * ---------------------------------------------------------- */
    
    /**
     * @dev Returns the current reflection rate
     */
    function _getRate() private view returns (uint256) {
        uint256 rSupply = _rTotal;
        uint256 tSupply = totalSupply();
        
        if (rSupply < _rTotal / 10000 || tSupply == 0) {
            return _rTotal / INITIAL_SUPPLY;
        }
        
        return rSupply / tSupply;
    }

    /**
     * @dev Returns token balance for an account
     */
    function balanceOf(address account) public view override returns (uint256) {
        if (isExcludedFromReflections[account]) {
            return _tOwned[account];
        }
        return _tokenFromReflection(_rOwned[account]);
    }

    /**
     * @dev Converts reflection amount to token amount
     */
    function _tokenFromReflection(uint256 rAmount) private view returns (uint256) {
        require(rAmount <= _rTotal, "Amount exceeds total reflections");
        uint256 currentRate = _getRate();
        return currentRate == 0 ? 0 : rAmount / currentRate;
    }

    /**
     * @dev Distributes reflection fees to all holders
     */
    function _reflectFee(uint256 rFee, uint256 tFee) private {
        if (rFee > _rTotal) return;
        
        _rTotal -= rFee;
        _tFeeTotal += tFee;
        
        emit ReflectionDistributed(tFee);
    }

    /* ---------------------------------------------------------- *
     * TRANSFER LOGIC                                              *
     * ---------------------------------------------------------- */
    
    /**
     * @dev Override _update to handle fees and burns
     */
    function _update(address from, address to, uint256 value) 
        internal 
        override 
        whenNotPaused
    {
        // Allow minting/burning and prevent recursion
        if (from == address(0) || to == address(0) || _inSwap) {
            super._update(from, to, value);
            return;
        }

        require(value > 0, "Transfer amount must be greater than zero");

        // Handle burn transfers
        if (to == BURN_ADDRESS) {
            _executeBurn(from, value);
            return;
        }

        // Auto-disable fees if minimum supply reached
        if (feesActive && totalSupply() <= MIN_SUPPLY) {
            feesActive = false;
            emit FeesToggled(false);
            emit MinimumSupplyReached();
        }

        // Determine if fees should be applied
        bool takeFee = feesActive && 
                      !isExcludedFromFees[from] && 
                      !isExcludedFromFees[to];

        if (takeFee) {
            _transferWithFees(from, to, value);
        } else {
            _transferStandard(from, to, value);
        }
    }

    /**
     * @dev Transfer with fees applied
     */
    function _transferWithFees(address from, address to, uint256 tAmount) private lockTheSwap {
        // Calculate fees
        uint256 burnAmount = (tAmount * burnFeeBps) / 10_000;
        uint256 reflectionAmount = (tAmount * reflectionFeeBps) / 10_000;
        uint256 creatorAmount = (tAmount * creatorFeeBps) / 10_000;
        uint256 totalFees = burnAmount + reflectionAmount + creatorAmount;
        
        require(tAmount > totalFees, "Fees exceed transfer amount");
        uint256 transferAmount = tAmount - totalFees;

        // Process reflection fee first
        if (reflectionAmount > 0) {
            uint256 currentRate = _getRate();
            _reflectFee(reflectionAmount * currentRate, reflectionAmount);
        }
        
        // Transfer to creator
        if (creatorAmount > 0) {
            _transferStandard(from, creatorWallet, creatorAmount);
        }

        // Execute burn (check minimum supply inside)
        if (burnAmount > 0) {
            _executeBurn(from, burnAmount);
        }

        // Transfer remaining amount to recipient
        _transferStandard(from, to, transferAmount);
    }

    /**
     * @dev Standard transfer without fees
     */
    function _transferStandard(address from, address to, uint256 tAmount) private {
        uint256 currentRate = _getRate();
        uint256 rAmount = tAmount * currentRate;

        // Update reflection balances
        if (isExcludedFromReflections[from]) {
            _tOwned[from] -= tAmount;
        } else {
            _rOwned[from] -= rAmount;
        }

        if (isExcludedFromReflections[to]) {
            _tOwned[to] += tAmount;
        } else {
            _rOwned[to] += rAmount;
        }

        // Update ERC20 balances
        super._update(from, to, tAmount);
    }

    /* ---------------------------------------------------------- *
     * BURN FUNCTIONALITY                                         *
     * ---------------------------------------------------------- */
    
    /**
     * @dev Execute burn operation with minimum supply protection
     */
    function _executeBurn(address from, uint256 amount) private {
        require(amount > 0, "Burn amount must be greater than zero");
        require(balanceOf(from) >= amount, "Insufficient balance for burn");
        
        // Check if burn would violate minimum supply
        uint256 newSupply = totalSupply() - amount;
        if (newSupply < MIN_SUPPLY) {
            // Only burn up to minimum supply
            amount = totalSupply() - MIN_SUPPLY;
            if (amount == 0) return; // Nothing to burn
        }

        uint256 currentRate = _getRate();
        uint256 rAmount = amount * currentRate;

        // Update sender's balance
        if (isExcludedFromReflections[from]) {
            _tOwned[from] -= amount;
        } else {
            _rOwned[from] -= rAmount;
        }

        // Reduce reflection total
        _rTotal -= rAmount;

        // Burn tokens (reduces total supply)
        super._update(from, address(0), amount);

        emit TokensBurned(from, amount);
        
        // Check if minimum supply reached
        if (totalSupply() <= MIN_SUPPLY) {
            emit MinimumSupplyReached();
        }
    }

    /**
     * @dev Public burn function
     */
    function burn(uint256 amount) external whenNotPaused {
        _executeBurn(msg.sender, amount);
    }

    /* ---------------------------------------------------------- *
     * EXCLUSION MANAGEMENT                                        *
     * ---------------------------------------------------------- */
    
    /**
     * @dev Setup initial exclusions for system addresses
     */
    function _setupInitialExclusions() private {
        // Exclude deployer (creator)
        isExcludedFromFees[msg.sender] = true;
        isExcludedFromReflections[msg.sender] = true;
        _excluded.push(msg.sender);
        
        // Exclude contract
        isExcludedFromFees[address(this)] = true;
        isExcludedFromReflections[address(this)] = true;
        _excluded.push(address(this));
        
        // Exclude burn address
        isExcludedFromFees[BURN_ADDRESS] = true;
        isExcludedFromReflections[BURN_ADDRESS] = true;
        _excluded.push(BURN_ADDRESS);
    }

    /**
     * @dev Exclude/include account from fees
     */
    function setFeeExclusion(address account, bool excluded) 
        external 
        onlyOwner 
        validAddress(account)
        notSystemAddress(account)
    {
        if (isExcludedFromFees[account] != excluded) {
            isExcludedFromFees[account] = excluded;
            emit ExclusionUpdated(account, excluded, isExcludedFromReflections[account]);
        }
    }

    /**
     * @dev Exclude/include account from reflections
     */
    function setReflectionExclusion(address account, bool excluded) 
        external 
        onlyOwner 
        validAddress(account)
        notSystemAddress(account)
    {
        if (isExcludedFromReflections[account] == excluded) {
            return; // No change needed
        }

        if (excluded) {
            require(_excluded.length < MAX_EXCLUDED_ACCOUNTS, "Max excluded accounts reached");
            
            _tOwned[account] = balanceOf(account);
            isExcludedFromReflections[account] = true;
            _excluded.push(account);
        } else {
            uint256 currentRate = _getRate();
            _rOwned[account] = _tOwned[account] * currentRate;
            _tOwned[account] = 0;
            isExcludedFromReflections[account] = false;

            // Remove from excluded array
            for (uint256 i = 0; i < _excluded.length; i++) {
                if (_excluded[i] == account) {
                    _excluded[i] = _excluded[_excluded.length - 1];
                    _excluded.pop();
                    break;
                }
            }
        }

        emit ExclusionUpdated(account, isExcludedFromFees[account], excluded);
    }

    /* ---------------------------------------------------------- *
     * ADMIN FUNCTIONS                                             *
     * ---------------------------------------------------------- */
    
    /**
     * @dev Update fee percentages
     */
    function updateFees(
        uint256 newBurnFee,
        uint256 newReflectionFee,
        uint256 newCreatorFee
    ) external onlyOwner {
        require(
            newBurnFee + newReflectionFee + newCreatorFee <= MAX_FEE_BPS,
            "Total fees exceed maximum"
        );
        
        burnFeeBps = newBurnFee;
        reflectionFeeBps = newReflectionFee;
        creatorFeeBps = newCreatorFee;
        
        emit FeesUpdated(newBurnFee, newReflectionFee, newCreatorFee);
    }

    /**
     * @dev Update creator wallet with proper exclusion management
     */
    function updateCreatorWallet(address newWallet) 
        external 
        onlyOwner 
        validAddress(newWallet)
    {
        require(newWallet != creatorWallet, "Same wallet as current");
        
        address oldWallet = creatorWallet;
        
        // Remove old wallet from exclusions if it's not a system address
        if (oldWallet != address(this) && oldWallet != BURN_ADDRESS) {
            isExcludedFromFees[oldWallet] = false;
            isExcludedFromReflections[oldWallet] = false;
            
            // Remove from excluded array
            for (uint256 i = 0; i < _excluded.length; i++) {
                if (_excluded[i] == oldWallet) {
                    _excluded[i] = _excluded[_excluded.length - 1];
                    _excluded.pop();
                    break;
                }
            }
        }
        
        // Set new creator wallet
        creatorWallet = newWallet;
        
        // Add new wallet to exclusions
        isExcludedFromFees[newWallet] = true;
        isExcludedFromReflections[newWallet] = true;
        _tOwned[newWallet] = balanceOf(newWallet);
        _excluded.push(newWallet);
        
        emit CreatorWalletUpdated(oldWallet, newWallet);
    }

    /* ---------------------------------------------------------- *
     * TIMELOCK OPERATIONS                                         *
     * ---------------------------------------------------------- */
    
    /**
     * @dev Initiate fee toggle with timelock
     */
    function initiateFeeToggle(bool newState) external onlyOwner {
        if (feesActive == newState) return;
        
        pendingToggleFeesState = newState;
        nextToggleFeesTime = block.timestamp + TIMELOCK_DURATION;
    }

    /**
     * @dev Execute fee toggle after timelock
     */
    function executeFeeToggle() external onlyOwner {
        require(nextToggleFeesTime != 0, "No pending toggle operation");
        require(block.timestamp >= nextToggleFeesTime, "Timelock not expired");
        
        feesActive = pendingToggleFeesState;
        nextToggleFeesTime = 0;
        
        emit FeesToggled(feesActive);
    }

    /* ---------------------------------------------------------- *
     * EMERGENCY FUNCTIONS                                         *
     * ---------------------------------------------------------- */
    
    /**
     * @dev Emergency pause all transfers
     */
    function emergencyPause() external onlyOwner {
        _pause();
    }

    /**
     * @dev Emergency unpause all transfers
     */
    function emergencyUnpause() external onlyOwner {
        _unpause();
    }

    /**
     * @dev Recover accidentally sent ERC20 tokens
     */
    function recoverStrandedTokens(address token, uint256 amount) 
        external 
        onlyOwner 
        validAddress(token)
    {
        require(token != address(this), "Cannot recover native token");
        IERC20(token).safeTransfer(owner(), amount);
    }

    /**
     * @dev Recover accidentally sent ETH/BNB
     */
    function recoverStrandedETH() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No ETH to recover");
        payable(owner()).transfer(balance);
    }

    /* ---------------------------------------------------------- *
     * VIEW FUNCTIONS                                              *
     * ---------------------------------------------------------- */
    
    /**
     * @dev Get reflection system information
     */
    function getReflectionInfo() external view returns (
        uint256 rTotal,
        uint256 tFeeTotal,
        uint256 currentRate,
        uint256 excludedCount
    ) {
        return (_rTotal, _tFeeTotal, _getRate(), _excluded.length);
    }

    /**
     * @dev Get fee configuration information
     */
    function getFeeInfo() external view returns (
        uint256 burnFee,
        uint256 reflectionFee,
        uint256 creatorFee,
        uint256 totalFee,
        bool active
    ) {
        uint256 total = burnFeeBps + reflectionFeeBps + creatorFeeBps;
        return (burnFeeBps, reflectionFeeBps, creatorFeeBps, total, feesActive);
    }

    /**
     * @dev Get timelock information
     */
    function getTimelockInfo() external view returns (
        uint256 nextToggleTime,
        bool pendingState,
        bool canExecute
    ) {
        bool canExec = nextToggleFeesTime != 0 && block.timestamp >= nextToggleFeesTime;
        return (nextToggleFeesTime, pendingToggleFeesState, canExec);
    }

    /**
     * @dev Get excluded addresses (for transparency)
     */
    function getExcludedAddresses() external view returns (address[] memory) {
        return _excluded;
    }

    /* ---------------------------------------------------------- *
     * OVERRIDE FUNCTIONS                                          *
     * ---------------------------------------------------------- */
    
    function decimals() public pure override returns (uint8) {
        return DECIMALS;
    }

    /**
     * @dev Receive ETH/BNB for DEX operations
     */
    receive() external payable {}
}
